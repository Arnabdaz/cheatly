[
  {
    "id": 1,
    "name": "1. binarySearch",
    "code": "#include<bits/stdc++.h>\r\n#include <time.h>\r\nusing namespace std;\r\n\r\nint binarysearch(int arr[], int size, int key)\r\n{\r\n    int start =0;\r\n    int end = size-1;\r\n\r\n    int mid = (start+end)/2;\r\n   \r\n   while(start <= end)\r\n   {\r\n    if(arr[mid] == key)\r\n        return mid;\r\n\r\n        if(key > arr[mid])\r\n        start= mid + 1;\r\n\r\n        else \r\n        end = mid - 1;\r\n\r\n        mid = (start + end)/2 ;\r\n\r\n   }\r\n\r\n   return -1 ;\r\n\r\n}\r\n\r\nint main()\r\n{\r\n\t\r\n    int even[6]={2,4,6,8,12,18};\r\n    int odd[5]={3,8,11,14,16};\r\n\r\n    clock_t start,end;\r\n    start = clock();\r\n\tint evenindex = binarysearch(even , 6 , 18);\r\n    end = clock();\r\n    long int time = (double)(end - start);\r\n    cout<<time;\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "lang": "cpp"
  },
  {
    "id": 2,
    "name": "2. bubbleSort",
    "code": "#include <Bits/stdc++.h>\r\n#include <time.h>\r\nusing namespace std;\r\n\r\nvoid bubbleSort(int array[], int size) {\r\n  for (int step = 0; step < size; ++step) {\r\n    for (int i = 0; i < size - step; ++i) {\r\n      if (array[i] > array[i + 1]) {\r\n        int temp = array[i];\r\n        array[i] = array[i + 1];\r\n        array[i + 1] = temp;\r\n      }\r\n    }\r\n  }\r\n}\r\nint main()\r\n{\r\n\r\n    int n;\r\n    cin >> n;\r\n\r\n    int arr[n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        arr[i] = rand();\r\n    }\r\n\r\n    float time = 0;\r\n\r\n    clock_t start, end;\r\n\r\n    start = clock();\r\n    bubbleSort(arr,n);\r\n    end = clock();\r\n\r\n    time = (float)(end - start);\r\n\r\n       cout << \"time required = \" << time << endl;\r\n\r\n    return 0;\r\n}",
    "lang": "cpp"
  },
  {
    "id": 3,
    "name": "3. insertionSort",
    "code": "#include<bits/stdc++.h>\r\n#include <time.h>\r\nusing namespace std;\r\n\r\nvoid insertionSort(int array[], int size) {\r\n  for (int step = 1; step < size; step++) {\r\n    int key = array[step];\r\n    int j = step - 1;\r\n    while (key < array[j] && j >= 0) {\r\n      array[j + 1] = array[j];\r\n      --j;\r\n    }\r\n    array[j + 1] = key;\r\n  }\r\n}\r\n\r\nint main()\r\n{\r\n\tlong int n;\r\n\tcin>>n;\r\n\tint array[n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        array[i] = rand();\r\n    }\r\n\r\n    clock_t start,end;\r\n    start = clock();\r\n\tinsertionSort(array,n);\r\n    end = clock();\r\n    long int time = (double)(end - start);\r\n    cout<<time;\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "lang": "cpp"
  },
  {
    "id": 4,
    "name": "4. selectionSort",
    "code": "#include <Bits/stdc++.h>\r\n#include <time.h>\r\nusing namespace std;\r\n\r\nvoid swap(int *a, int *b)\r\n{\r\n    int temp = *a;\r\n    *a = *b;\r\n    *b = temp;\r\n}\r\n\r\nvoid selectionSort(int arr[], int n)\r\n{\r\n    int i, j, min_ind;\r\n    for (i = 0; i < n - 1; i++)\r\n    {\r\n        min_ind = i;\r\n        for (j = i + 1; j < n; j++)\r\n        {\r\n            if (arr[j] < arr[min_ind])\r\n                min_ind = j;\r\n        }\r\n\r\n        swap(&arr[min_ind], &arr[i]);\r\n    }\r\n}\r\nint main()\r\n{\r\n\r\n    int n;\r\n    cin >> n;\r\n\r\n    int arr[n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        arr[i] = rand();\r\n    }\r\n\r\n    float time = 0;\r\n\r\n    clock_t start, end;\r\n\r\n    start = clock();\r\n    selectionSort(arr, n);\r\n    end = clock();\r\n\r\n    time = (float)(end - start);\r\n\r\n       cout << \"time required = \" << time << endl;\r\n\r\n    return 0;\r\n}",
    "lang": "cpp"
  },
  {
    "id": 5,
    "name": "5. mergeSort",
    "code": "// Merge sort in C\r\n\r\n#include<bits/stdc++.h>\r\n#include <time.h>\r\nusing namespace std;\r\n\r\n// Merge two subarrays L and M into arr\r\nvoid merge(int arr[], int p, int q, int r) {\r\n\r\n  // Create L ← A[p..q] and M ← A[q+1..r]\r\n  int n1 = q - p + 1;\r\n  int n2 = r - q;\r\n\r\n  int L[n1], M[n2];\r\n\r\n  for (int i = 0; i < n1; i++)\r\n    L[i] = arr[p + i];\r\n  for (int j = 0; j < n2; j++)\r\n    M[j] = arr[q + 1 + j];\r\n\r\n  // Maintain current index of sub-arrays and main array\r\n  int i, j, k;\r\n  i = 0;\r\n  j = 0;\r\n  k = p;\r\n\r\n  // Until we reach either end of either L or M, pick larger among\r\n  // elements L and M and place them in the correct position at A[p..r]\r\n  while (i < n1 && j < n2) {\r\n    if (L[i] <= M[j]) {\r\n      arr[k] = L[i];\r\n      i++;\r\n    } else {\r\n      arr[k] = M[j];\r\n      j++;\r\n    }\r\n    k++;\r\n  }\r\n\r\n  // When we run out of elements in either L or M,\r\n  // pick up the remaining elements and put in A[p..r]\r\n  while (i < n1) {\r\n    arr[k] = L[i];\r\n    i++;\r\n    k++;\r\n  }\r\n\r\n  while (j < n2) {\r\n    arr[k] = M[j];\r\n    j++;\r\n    k++;\r\n  }\r\n}\r\n\r\n// Divide the array into two subarrays, sort them and merge them\r\nvoid mergeSort(int arr[], int l, int r) {\r\n  if (l < r) {\r\n\r\n    // m is the point where the array is divided into two subarrays\r\n    int m = l + (r - l) / 2;\r\n\r\n    mergeSort(arr, l, m);\r\n    mergeSort(arr, m + 1, r);\r\n\r\n    // Merge the sorted subarrays\r\n    merge(arr, l, m, r);\r\n  }\r\n}\r\n\r\n\r\n\r\n// Main Function\r\nint main()\r\n{\r\n\tlong int n;\r\n\tcin>>n;\r\n\tint array[n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        array[i] = rand();\r\n    }\r\n\r\n    clock_t start,end;\r\n    start = clock();\r\n\t  mergeSort(array, 0, n - 1);\r\n    end = clock();\r\n    long int time = (double)(end - start);\r\n    cout<<time;\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "lang": "cpp"
  },
  {
    "id": 6,
    "name": "6. quickSort",
    "code": "#include <bits/stdc++.h>\r\n#include <time.h>\r\nusing namespace std;\r\n\r\nvoid swap(int *a, int *b)\r\n{\r\n    int t = *a;\r\n    *a = *b;\r\n    *b = t;\r\n}\r\nvoid printArray(int array[], int size)\r\n{\r\n    int i;\r\n    for (i = 0; i < size; i++)\r\n        cout << array[i] << \" \";\r\n    cout << endl;\r\n}\r\n\r\nint partition(int array[], int low, int high)\r\n{\r\n\r\n    int pivot = array[high];\r\n    int i = (low - 1);\r\n    for (int j = low; j < high; j++)\r\n    {\r\n        if (array[j] <= pivot)\r\n        {\r\n            i++;\r\n            swap(&array[i], &array[j]);\r\n        }\r\n    }\r\n    swap(&array[i + 1], &array[high]);\r\n    return (i + 1);\r\n}\r\n\r\nvoid quickSort(int array[], int low, int high)\r\n{\r\n    if (low < high)\r\n    {\r\n        int pi = partition(array, low, high);\r\n        quickSort(array, low, pi - 1);\r\n        quickSort(array, pi + 1, high);\r\n    }\r\n}\r\nint main()\r\n{\r\n    long int n;\r\n    cin >> n;\r\n    int array[n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        array[i] = rand();\r\n    }\r\n\r\n    clock_t start, end;\r\n    start = clock();\r\n    quickSort(array,0,n-1);\r\n    end = clock();\r\n    long int time = (double)(end - start);\r\n    cout << time;\r\n\r\n    return 0;\r\n}\r\n",
    "lang": "cpp"
  },
  {
    "id": 7,
    "name": "7. graph BFS",
    "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass graph\r\n{\r\n    int V;\r\n    vector<vector<int>> adj;\r\n\r\npublic:\r\n    graph(int V)\r\n    {\r\n        this->V = V;\r\n        adj.resize(V);\r\n    }\r\n\r\n    void addedge(int u, int v)\r\n    {\r\n        adj[u].push_back(v);\r\n        adj[v].push_back(u);\r\n    }\r\n\r\n    void bfs(int s, vector<int> &ans)\r\n    {\r\n        vector<bool> vis(V + 1, false);\r\n        queue<int> q;\r\n        q.push(s);\r\n        vis[s] = true;\r\n\r\n        while (!q.empty())\r\n        {\r\n            int u = q.front();\r\n            q.pop();\r\n            ans.push_back(u);\r\n\r\n            for (auto x : adj[u])\r\n            {\r\n                if (!vis[x])\r\n                {\r\n                    q.push(x);\r\n                    vis[x] = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n\r\n    graph g(7);\r\n\r\n    g.addedge(0, 1);\r\n    g.addedge(0, 3);\r\n    g.addedge(1, 2);\r\n    g.addedge(2, 4);\r\n    g.addedge(3, 2);\r\n    g.addedge(2, 5);\r\n    g.addedge(1, 6);\r\n\r\n    vector<int> ans;\r\n    g.bfs(0, ans);\r\n\r\n    cout << \"bfs of graph\" << endl;\r\n    for (auto it : ans)\r\n    {\r\n        cout << it << \" \";\r\n    }\r\n    return 0;\r\n}",
    "lang": "cpp"
  },
  {
    "id": 8,
    "name": "8. graph DFS",
    "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass graph{\r\n    int V;\r\n    vector<vector<int>> adj;\r\n\r\n    public:\r\n\r\n    graph(int V){\r\n        this->V = V;\r\n        adj.resize(V);\r\n    }\r\n     \r\n    void addedge(int u ,int v){\r\n         adj[u].push_back(v);\r\n         adj[v].push_back(u);\r\n    }\r\n\r\n    void dfs(int s,vector<bool> &visited ,vector<int> &ans2){\r\n        visited[s] = true;\r\n        ans2.push_back(s);\r\n\r\n        for(auto x:adj[s]){\r\n            if(!visited[x]){\r\n                dfs(x,visited,ans2);\r\n            }\r\n        }\r\n    }\r\n\r\n};\r\n\r\nint main(){\r\n   \r\n    graph g(7);\r\n\r\n    g.addedge(0,1);\r\n    g.addedge(0,3);\r\n    g.addedge(1,2);\r\n    g.addedge(2,4);\r\n    g.addedge(3,2);\r\n    g.addedge(2,5);\r\n    g.addedge(1,6);\r\n    \r\n    vector<bool> visited(7+1,false);\r\n    vector<int> ans;\r\n    for(int i = 0 ;i<7;i++){\r\n        if(!visited[i]){\r\n            g.dfs(i,visited,ans);\r\n        }\r\n    }\r\n    cout<<endl;\r\n    cout<<\"dfs of graph\"<<endl;\r\n    for(auto it:ans){\r\n        cout<<it<<\" \";\r\n    }\r\n\r\n\r\n    return 0;\r\n}",
    "lang": "cpp"
  },
  {
    "id": 9,
    "name": "9. Dijkstra",
    "code": "#include <iostream>\r\nusing namespace std;\r\n\r\n#define V 9\r\n\r\nint minDistance(int dist[], bool visited[])\r\n{\r\n\r\n    // Initialize min value\r\n    int min = 1e5;\r\n    int min_index;\r\n\r\n    for (int v = 0; v < V; v++)\r\n        if (visited[v] == false && dist[v] <= min)\r\n        {\r\n            min = dist[v];\r\n            min_index = v;\r\n        }\r\n    return min_index;\r\n}\r\n\r\nvoid printSolution(int dist[])\r\n{\r\n    cout << \"Vertex \\t Distance from Source\" << endl;\r\n    for (int i = 0; i < V; i++)\r\n        cout << i << \" \\t\\t\\t\\t\" << dist[i] << endl;\r\n}\r\n\r\nvoid dijkstra(int graph[V][V], int src)\r\n{\r\n    int dist[V];\r\n    bool visited[V];\r\n\r\n    for (int i = 0; i < V; i++)\r\n    {\r\n        dist[i] = 1e5;\r\n        visited[i] = false;\r\n    }\r\n    dist[src] = 0;\r\n\r\n    for (int count = 0; count < V - 1; count++)\r\n    {\r\n\r\n        int u = minDistance(dist, visited);\r\n        visited[u] = true;\r\n\r\n        for (int v = 0; v < V; v++)\r\n            if (!visited[v] && graph[u][v] && dist[u] != 1e5 && dist[u] + graph[u][v] < dist[v])\r\n                dist[v] = dist[u] + graph[u][v];\r\n\r\n    }\r\n\r\n    printSolution(dist);\r\n}\r\n\r\nint main()\r\n{\r\n\r\n    int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\r\n                       {4, 0, 8, 0, 0, 0, 0, 11, 0},\r\n                       {0, 8, 0, 7, 0, 4, 0, 0, 2},\r\n                       {0, 0, 7, 0, 9, 14, 0, 0, 0},\r\n                       {0, 0, 0, 9, 0, 10, 0, 0, 0},\r\n                       {0, 0, 4, 14, 10, 0, 2, 0, 0},\r\n                       {0, 0, 0, 0, 0, 2, 0, 1, 6},\r\n                       {8, 11, 0, 0, 0, 0, 1, 0, 7},\r\n                       {0, 0, 2, 0, 0, 0, 6, 7, 0}};\r\n\r\n    dijkstra(graph, 0);\r\n\r\n    return 0;\r\n}",
    "lang": "cpp"
  },
  {
    "id": 10,
    "name": "10. Bellman Ford",
    "code": "\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Edge\r\n{\r\n    int src, dest, weight;\r\n};\r\n\r\nstruct Graph\r\n{\r\n    int V, E;\r\n    struct Edge *edge;\r\n};\r\n\r\nstruct Graph *createGraph(int V, int E)\r\n{\r\n    struct Graph *graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\n\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex Distance from Source\\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d \\t\\t %d\\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph *graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n\r\n    for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n    for (int i = 1; i <= V - 1; i++)\r\n    {\r\n        for (int j = 0; j < E; j++)\r\n        {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n    for (int i = 0; i < E; i++)\r\n    {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n        {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printArr(dist, V);\r\n\r\n    return;\r\n}\r\n\r\n// Driver's code\r\nint main()\r\n{\r\n\r\n    int V = 5;\r\n    int E = 8;\r\n    struct Graph *graph = createGraph(V, E);\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n\r\n    BellmanFord(graph, 0);\r\n\r\n    return 0;\r\n}\r\n",
    "lang": "cpp"
  },
  {
    "id": 11,
    "name": "11. string Matching",
    "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nvoid search(char* pat, char* txt)\r\n{\r\n\tint M = strlen(pat);\r\n\tint N = strlen(txt);\r\n\tfor (int i = 0; i <= N - M; i++) {\r\n\t\tint j;\r\n\t\tfor (j = 0; j < M; j++)\r\n\t\t\tif (txt[i + j] != pat[j])\r\n\t\t\t\tbreak;\r\n\t\tif (j==M)\r\n\t\t\tcout << \"Pattern found at index \" << i << endl;\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tchar txt[] = \"AABAACAADAABAAABAA\";\r\n\tchar pat[] = \"AABA\";\r\n\tsearch(pat, txt);\r\n\treturn 0;\r\n}\r\n\r\n\r\n",
    "lang": "cpp"
  },
  {
    "id": 12,
    "name": "12. binary knapsack",
    "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nint max(int a, int b) { return (a > b) ? a : b; }\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n\tif (n == 0 || W == 0)\r\n\t\treturn 0;\r\n\tif (wt[n - 1] > W)\r\n\t\treturn knapSack(W, wt, val, n - 1);\r\n\telse\r\n\t\treturn max(\r\n\t\t\tval[n - 1]\r\n\t\t\t\t+ knapSack(W - wt[n - 1], wt, val, n - 1),\r\n\t\t\tknapSack(W, wt, val, n - 1));\r\n}\r\nint main()\r\n{\r\n\tint profit[] = { 60, 100, 120 };\r\n\tint weight[] = { 10, 20, 30 };\r\n\tint W = 50;\r\n\tint n = sizeof(profit) / sizeof(profit[0]);\r\n\tcout << knapSack(W, weight, profit, n);\r\n\treturn 0;\r\n}",
    "lang": "cpp"
  },
  {
    "id": 13,
    "name": "13. fractional knapsack",
    "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct Item {\r\n\tint profit, weight;\r\n\tItem(int profit, int weight)\r\n\t{\r\n\t\tthis->profit = profit;\r\n\t\tthis->weight = weight;\r\n\t}\r\n};\r\nstatic bool cmp(struct Item a, struct Item b)\r\n{\r\n\tdouble r1 = (double)a.profit / (double)a.weight;\r\n\tdouble r2 = (double)b.profit / (double)b.weight;\r\n\treturn r1 > r2;\r\n}\r\ndouble fractionalKnapsack(int W, struct Item arr[], int N)\r\n{\r\n\tsort(arr, arr + N, cmp);\r\n\r\n\tdouble finalvalue = 0.0;\r\n\tfor (int i = 0; i < N; i++) {\r\n\t\tif (arr[i].weight <= W) {\r\n\t\t\tW -= arr[i].weight;\r\n\t\t\tfinalvalue += arr[i].profit;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfinalvalue\r\n\t\t\t\t+= arr[i].profit\r\n\t\t\t\t* ((double)W / (double)arr[i].weight);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn finalvalue;\r\n}\r\n\r\n// Driver code\r\nint main()\r\n{\r\n\tint W = 50;\r\n\tItem arr[] = { { 60, 10 }, { 100, 20 }, { 120, 30 } };\r\n\tint N = sizeof(arr) / sizeof(arr[0]);\r\n\r\n\tcout << fractionalKnapsack(W, arr, N);\r\n\treturn 0;\r\n}\r\n",
    "lang": "cpp"
  },
  {
    "id": 14,
    "name": "14. floyd warshall",
    "code": "// C++ Program for Floyd Warshall Algorithm\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define V 4\r\n\r\n#define INF 99999\r\n\r\nvoid printSolution(int dist[][V]);\r\n\r\nvoid floydWarshall(int dist[][V])\r\n{\r\n\r\n    int i, j, k;\r\n\r\n    for (k = 0; k < V; k++)\r\n    {\r\n        for (i = 0; i < V; i++)\r\n        {\r\n            for (j = 0; j < V; j++)\r\n            {\r\n                if (dist[i][j] > (dist[i][k] + dist[k][j]) && (dist[k][j] != INF && dist[i][k] != INF))\r\n                    dist[i][j] = dist[i][k] + dist[k][j];\r\n            }\r\n        }\r\n    }\r\n    printSolution(dist);\r\n}\r\nvoid printSolution(int dist[][V])\r\n{\r\n    cout << \"The following matrix shows the shortest \"\r\n            \"distances\"\r\n            \" between every pair of vertices \\n\";\r\n    for (int i = 0; i < V; i++)\r\n    {\r\n        for (int j = 0; j < V; j++)\r\n        {\r\n            if (dist[i][j] == INF)\r\n                cout << \"INF\"\r\n                     << \" \";\r\n            else\r\n                cout << dist[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\n// Driver's code\r\nint main()\r\n{\r\n    int graph[V][V] = {{0, 5, INF, 10},\r\n                       {INF, 0, 3, INF},\r\n                       {INF, INF, 0, 1},\r\n                       {INF, INF, INF, 0}};\r\n\r\n    // Function call\r\n    floydWarshall(graph);\r\n    return 0;\r\n}\r\n",
    "lang": "cpp"
  },
  {
    "id": 15,
    "name": "15. kruskals",
    "code": "// C++ program for the above approach\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// DSU data structure\r\n// path compression + rank by union\r\nclass DSU {\r\n\tint* parent;\r\n\tint* rank;\r\n\r\npublic:\r\n\tDSU(int n)\r\n\t{\r\n\t\tparent = new int[n];\r\n\t\trank = new int[n];\r\n\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tparent[i] = -1;\r\n\t\t\trank[i] = 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// Find function\r\n\tint find(int i)\r\n\t{\r\n\t\tif (parent[i] == -1)\r\n\t\t\treturn i;\r\n\r\n\t\treturn parent[i] = find(parent[i]);\r\n\t}\r\n\r\n\t// Union function\r\n\tvoid unite(int x, int y)\r\n\t{\r\n\t\tint s1 = find(x);\r\n\t\tint s2 = find(y);\r\n\r\n\t\tif (s1 != s2) {\r\n\t\t\tif (rank[s1] < rank[s2]) {\r\n\t\t\t\tparent[s1] = s2;\r\n\t\t\t}\r\n\t\t\telse if (rank[s1] > rank[s2]) {\r\n\t\t\t\tparent[s2] = s1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tparent[s2] = s1;\r\n\t\t\t\trank[s1] += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nclass Graph {\r\n\tvector<vector<int> > edgelist;\r\n\tint V;\r\n\r\npublic:\r\n\tGraph(int V) { this->V = V; }\r\n\r\n\t// Function to add edge in a graph\r\n\tvoid addEdge(int x, int y, int w)\r\n\t{\r\n\t\tedgelist.push_back({ w, x, y });\r\n\t}\r\n\r\n\tvoid kruskals_mst()\r\n\t{\r\n\t\t// Sort all edges\r\n\t\tsort(edgelist.begin(), edgelist.end());\r\n\r\n\t\t// Initialize the DSU\r\n\t\tDSU s(V);\r\n\t\tint ans = 0;\r\n\t\tcout << \"Following are the edges in the \"\r\n\t\t\t\t\"constructed MST\"\r\n\t\t\t<< endl;\r\n\t\tfor (auto edge : edgelist) {\r\n\t\t\tint w = edge[0];\r\n\t\t\tint x = edge[1];\r\n\t\t\tint y = edge[2];\r\n\r\n\t\t\t// Take this edge in MST if it does\r\n\t\t\t// not forms a cycle\r\n\t\t\tif (s.find(x) != s.find(y)) {\r\n\t\t\t\ts.unite(x, y);\r\n\t\t\t\tans += w;\r\n\t\t\t\tcout << x << \" -- \" << y << \" == \" << w\r\n\t\t\t\t\t<< endl;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcout << \"Minimum Cost Spanning Tree: \" << ans;\r\n\t}\r\n};\r\n\r\n// Driver code\r\nint main()\r\n{\r\n\tGraph g(4);\r\n\tg.addEdge(0, 1, 10);\r\n\tg.addEdge(1, 3, 15);\r\n\tg.addEdge(2, 3, 4);\r\n\tg.addEdge(2, 0, 6);\r\n\tg.addEdge(0, 3, 5);\r\n\r\n\t// Function call\r\n\tg.kruskals_mst();\r\n\r\n\treturn 0;\r\n}\r\n",
    "lang": "cpp"
  },
  {
    "id": 16,
    "name": "16. prims",
    "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// Number of vertices in the graph\r\n#define V 9\r\n\r\nint minKey(int key[], bool mstSet[])\r\n{\r\n    // Initialize min value\r\n    int min = INT_MAX, min_index;\r\n\r\n    for (int v = 0; v < V; v++)\r\n        if (mstSet[v] == false && key[v] < min)\r\n            min = key[v], min_index = v;\r\n\r\n    return min_index;\r\n}\r\n\r\nvoid printMST(int parent[], int graph[V][V])\r\n{\r\n    cout << \"Edge \\tWeight\\n\";\r\n    for (int i = 1; i < V; i++)\r\n        cout << parent[i] << \" - \" << i << \" \\t\"\r\n             << graph[i][parent[i]] << \" \\n\";\r\n}\r\n\r\nvoid primMST(int graph[V][V])\r\n{\r\n    // Array to store constructed MST\r\n    int parent[V];\r\n\r\n    // Key values used to pick minimum weight edge in cut\r\n    int key[V];\r\n\r\n    // To represent set of vertices included in MST\r\n    bool mstSet[V];\r\n\r\n    // Initialize all keys as INFINITE\r\n    for (int i = 0; i < V; i++)\r\n        key[i] = INT_MAX, mstSet[i] = false;\r\n\r\n    key[0] = 0;\r\n\r\n    // First node is always root of MST\r\n    parent[0] = -1;\r\n\r\n    for (int count = 0; count < V - 1; count++)\r\n    {\r\n\r\n        int u = minKey(key, mstSet);\r\n\r\n        mstSet[u] = true;\r\n\r\n        for (int v = 0; v < V; v++)\r\n\r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])\r\n                parent[v] = u, key[v] = graph[u][v];\r\n    }\r\n\r\n    // Print the constructed MST\r\n    printMST(parent, graph);\r\n}\r\n\r\n// Driver's code\r\nint main()\r\n{\r\n    int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},\r\n                       {4, 0, 8, 0, 0, 0, 0, 11, 0},\r\n                       {0, 8, 0, 7, 0, 4, 0, 0, 2},\r\n                       {0, 0, 7, 0, 9, 14, 0, 0, 0},\r\n                       {0, 0, 0, 9, 0, 10, 0, 0, 0},\r\n                       {0, 0, 4, 14, 10, 0, 2, 0, 0},\r\n                       {0, 0, 0, 0, 0, 2, 0, 1, 6},\r\n                       {8, 11, 0, 0, 0, 0, 1, 0, 7},\r\n                       {0, 0, 2, 0, 0, 0, 6, 7, 0}};\r\n\r\n    // Print the solution\r\n    primMST(graph);\r\n\r\n    return 0;\r\n}\r\n\r\n// This code is contributed by rathbhupendra\r\n",
    "lang": "cpp"
  }
]
